// (c) joopl
// By Matías Fidemraizer (http://www.matiasfidemraizer.com) (http://www.linkedin.com/in/mfidemraizer/en)
// -------------------------------------------------
// http://joopl.codeplex.com
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Keywords
var $namespace = null; // Holds an object to manage namespaces
var $class = null; // Holds an object to manage class declarations and others
var $interface = null; // Holds an object to manage interface declarations and others
var $implements = null; // Holds a function to check if an object implements an interface
var $new = null; // A shortcut to $class.new(...) (OBSOLETE!)
var $def = null; // A shortcut to $class.declare(...)
var $interfacedef = null; // A shortcut to $interface.declare(...)
var $global = {}; // Represents the global scope.

(function (undefined) {
    "use strict";

    var version = "2.1.1";

    // Defines a pseudo-enumeration of type kinds.
    var TypeKinds = {
        Class: "class",
        Interface: "interface"
    };

    // An object containing a set of core features used by jOOPL
    var TypeUtil = {
        // Determines if some identifier is a jOOPL keyword.
        isSystemReservedName: function (name) {
            var reserved = false;

            switch (name) {
                case "$ctor":
                case "$bctor":
                case "$global":
                case "$def":
                case "$interfacedef":
                case "$new":
                case "$namespace":
                case "$extends":
                case "$implements":
                case "$_":
                case "joopl":
                case "typeKind":
                    return true;

                default:
                    return false;
            }
        },

        // It does the core operations to instantiate a class.
        createInstance: function (clazz, baseInstance) {
            var instance = null;

            if (this.isFunction(clazz)) {
                instance = new clazz();

                if (this.isFunction(instance.$base)) {
                    instance.$base = this.createInstance(instance.$base);
                    instance.$base.$_ = instance.$_;
                }
            }

            return instance;
        },

        createProperties: function (someInstance) {
            if (Object.defineProperty) {
                var isProperty = function (memberName) {
                    memberName = memberName.toLowerCase();
                    return memberName.indexOf("get_") == 0 || memberName.indexOf("set_") == 0;
                };

                var propertyName = null;
                var getterName = null;
                var setterName = null;
                var alreadyDefinedAccessors = [];

                // Converting accessors to properties...
                for (var memberName in someInstance) {
                    if (isProperty(memberName)) {
                        propertyName = memberName.substring(4);
                        propertyName = propertyName.charAt(0).toLowerCase() + propertyName.substring(1);

                        if (!someInstance.hasOwnProperty(propertyName) && alreadyDefinedAccessors.indexOf(propertyName.toLowerCase()) == -1) {
                            alreadyDefinedAccessors.push(propertyName.toLowerCase());

                            // Is it a getter?
                            if (memberName.indexOf("get_") == 0) {
                                setterName = memberName.replace("get_", "set_");

                                // Read-write property
                                if (someInstance[setterName]) {
                                    Object.defineProperty(
                                        someInstance,
                                        propertyName,
                                        {
                                            enumerable: true,
                                            configurable: false,
                                            get: someInstance[memberName].bind(someInstance),
                                            set: someInstance[setterName].bind(someInstance)
                                        }
                                    );
                                } else { // Read-only property
                                    Object.defineProperty(
                                        someInstance,
                                        propertyName,
                                        {
                                            enumerable: true,
                                            configurable: false,
                                            get: someInstance[memberName].bind(someInstance)
                                        }
                                    );
                                }
                            } else if (memberName.indexOf("set_") == 0) { // Is is a setter?
                                getterName = memberName.replace("set_", "get_");

                                // Read-write property
                                if (someInstance[getterName]) {
                                    Object.defineProperty(
                                        someInstance,
                                        propertyName,
                                        {
                                            enumerable: true,
                                            configurable: false,
                                            get: someInstance[getterName].bind(someInstance),
                                            set: someInstance[memberName].bind(someInstance)
                                        }
                                    );
                                } else { // Write-only property
                                    Object.defineProperty(
                                        someInstance,
                                        propertyName,
                                        {
                                            enumerable: true,
                                            configurable: false,
                                            get: someInstance[memberName].bind(someInstance)
                                        }
                                    );
                                }
                            }
                        }
                    }
                }

                if (someInstance.$base && someInstance.$base.joopl) {
                    this.createProperties(someInstance.$base);
                }
            }
        },

        // Recursively-creates some class instance fields.
        createFields: function (someInstance, fieldsInstance) {
            someInstance.$_ = TypeUtil.hasValue(fieldsInstance) ? fieldsInstance : {};

            if (TypeUtil.hasValue(someInstance.$base)) {
                this.createFields(someInstance.$base, someInstance.$_);
            }
        },

        inherits: function (derived, parent) {
            if (parent != null) {

                if (!this.isFunction(parent) || !this.isFunction(derived)) {
                    throw new Error("Parent and/or derived member must be a type");
                }

                for (var fieldName in parent.prototype.$_) {
                    if (!this.hasValue(derived.prototype.$_[fieldName])) {
                        derived.prototype.$_[fieldName] = parent.prototype.$_[fieldName];
                    }
                }

                for (var memberName in parent.prototype) {
                    if (!this.isSystemReservedName(memberName)) {
                        if (this.isFunction(parent.prototype[memberName])) {
                            derived.prototype[memberName] = parent.prototype[memberName];
                        }
                    }
                }
            }

            return this.hasValue(parent) ? parent.prototype : null;
        },

        hasValue: function (someRef) {
            return someRef !== undefined && someRef != null;
        },

        isFunction: function (someRef) {
            return this.hasValue(someRef)
                    && typeof someRef === "function";
        },

        isArray: function (someRef) {
            return this.hasValue(someRef)
                    && typeof someRef === "Array";
        },

        isString: function (someRef) {
            return this.hasValue(someRef)
                    && typeof someRef === "string";
        }
    };

    Object.preventExtensions(TypeUtil);

    $namespace = {
        register: function (path, scopedFunc) {
            var nsIdentifiers = TypeUtil.isString(path) ? path.split(".") : null;
            var parentNs = $global;
            var currentNs = null;

            for (var nsIndex = 0; nsIndex < nsIdentifiers.length; nsIndex++) {
                currentNs = nsIdentifiers[nsIndex];

                if (!TypeUtil.hasValue(parentNs[currentNs])) {
                    parentNs[currentNs] = {};

                    Object.defineProperty(
                        parentNs[currentNs], "isNamespace", {
                            get: function () { return true; },
                            configurable: false
                        });
                }

                parentNs = parentNs[currentNs];
            }

            if (scopedFunc) {
                $namespace.using(path, scopedFunc, true);
            }
        },

        alias: function (namespace, alias) {
            $global[alias] = namespace;
        },

        using: function (paths, scopedFunc, scopeIsNs) {
            if (paths === undefined) {
                throw Error("Namespace import failed. No path given!");
            }

            if (typeof paths == "string") {
                paths = [paths];
            }

            var nsIdentifiers = null;
            var parentNs = $global;
            var currentNs = null;
            var isType = false;
            var nsIndex = 0;

            var namespaces = [];

            for (var pathIndex in paths) {
                nsIdentifiers = paths[pathIndex].split(".");

                while (!isType && nsIndex < nsIdentifiers.length) {
                    currentNs = parentNs[nsIdentifiers[nsIndex]];

                    if (!TypeUtil.hasValue(currentNs)) {
                        throw Error("Namespace '" + paths + "' not found");
                    }

                    if (TypeUtil.hasValue(currentNs)) {
                        if (!TypeUtil.hasValue(currentNs.joopl)) {
                            parentNs = currentNs;
                            nsIndex++;
                        }
                        else {
                            isType = true;
                        }
                    }
                }

                namespaces.push(parentNs);

                parentNs = $global;
                isType = false;
                nsIndex = 0;
            }

            var nsScope = {};
            var nsIndex = 0;

            for (nsIndex in namespaces) {
                for (var typeName in namespaces[nsIndex]) {
                    if (!TypeUtil.hasValue(nsScope[typeName])) {
                        if ((namespaces[nsIndex][typeName].prototype !== undefined && !namespaces[nsIndex][typeName].prototype.joopl !== undefined) || namespaces[nsIndex][typeName].joopl !== undefined) {
                            nsScope[typeName] = namespaces[nsIndex][typeName];
                        }
                    }
                    else {
                        throw Error("A type called '" + typeName + "' in current context from another namespace already exists. Create an alias or use a full namespace paths");
                    }
                }
            }

            Object.preventExtensions(nsScope);

            if (scopedFunc !== undefined && typeof scopedFunc == "function") {
                if (scopeIsNs) {
                    scopedFunc.bind(namespaces[nsIndex])();
                } else if (scopedFunc.length == 0) {
                    scopedFunc.bind(nsScope)();
                } else {
                    scopedFunc.bind($global)(nsScope);
                }

                return null;
            } else {
                return nsScope;
            }
        }
    };

    Object.preventExtensions($namespace);

    $interface = {

        isInterface: function (someRef) {
            return TypeUtil.isFunction(someRef)
                                ? someRef.prototype.typeKind : someRef.typeKind;
        },

        declare: function (args) {
            var interfaceDef = function () {
            };

            interfaceDef.prototype.joopl = version;

            Object.defineProperty(interfaceDef.prototype, "typeKind", { value: TypeKinds.Interface, enumerable: true });

            if (typeof args.$extends != "Array") {
                TypeUtil.inherits(interfaceDef, args.$extends);
            }
            else {
                for (var interfaceIndex = 0; interfaceIndex < args.$extends.length; interfaceIndex++) {
                    TypeUtil.inherits(interfaceDef, args.$extends[interfaceIndex]);
                }
            }

            if (args.$members) {
                for (var memberName in args.$members) {
                    interfaceDef.prototype[memberName] = args.$members[memberName];
                }
            }

            return interfaceDef;
        },

        implementz: function (clazz, someInterface) {
            if (clazz == null) {
                throw new $global.joopl.ArgumentNullException({ ArgName: "clazz" });
            }

            if (someInterface == null) {
                throw new $global.joopl.ArgumentNullException({ ArgName: "someInterface" });
            }

            if (!$class.isClass(clazz)) {
                throw new $global.joopl.NotClassException();
            }

            if (!$interface.isInterface(someInterface)) {
                throw new $global.joopl.NotInterfaceException();
            }

            for (var interfaceMember in someInterface.prototype) {
                if (
                        TypeUtil.isFunction(someInterface.prototype[interfaceMember])
                        &&
                        (
                            !TypeUtil.isFunction(clazz.prototype[interfaceMember])
                            || clazz.prototype[interfaceMember] === undefined
                            || clazz.prototype[interfaceMember].length !== someInterface.prototype[interfaceMember].length
                        )
                ) {
                    return { success: false, memberName: interfaceMember };
                }
            }

            return { success: true, memberName: null };
        }
    };

    $implements = $interface.implementz;
    $interfacedef = $interface.declare;

    Object.preventExtensions($interface);
    Object.preventExtensions($interfacedef);
    Object.preventExtensions($implements);

    $class = {
        isClass: function (someRef) {
            return (TypeUtil.isFunction(someRef) ?
                        someRef.prototype.typeKind : someRef.typeKind) == TypeKinds.Class;
        },

        inherits: function (derived, parent) {
            if (!$class.isClass(derived)) {
                throw Error("Not a class");
            }

            if (!$class.isClass(derived)) {
                throw Error("Not a class");
            }

            return TypeUtil.inherits(derived, parent);
        },

        declare: function (args) {
            var classDef = function (args) {
                $class.create(this, args);
            };

            Object.defineProperty(classDef.prototype, "joopl", { value: version, enumerable: true });
            Object.defineProperty(classDef.prototype, "typeKind", { value: TypeKinds.Class, enumerable: true });

            if (args.$constructor) {
                classDef.prototype.$ctor = args.$constructor;
            } else {
                classDef.prototype.$ctor = function () { };
            }

            if (args.$extends) {
                this.inherits(classDef, args.$extends);
                classDef.prototype.$base = args.$extends;
            }

            if (args.$members) {
                for (var memberName in args.$members) {
                    if (TypeUtil.isFunction(args.$members[memberName])) {
                        classDef.prototype[memberName] = args.$members[memberName];
                    }
                }
            }

            if (args.$implements) {
                var interfaceResultTuple = null;

                if (!TypeUtil.isArray(args.$implements)) {
                    interfaceResultTuple = $interface.implementz(classDef, args.$implements);

                    if (!interfaceResultTuple.success) {
                        throw new $global.joopl.NotImplementedException({ memberName: interfaceResultTuple.memberName });
                    }
                }
                else {
                    for (var someInterface in args.$implements) {
                        interfaceResultTuple = $interface.implementz(classDef, args.$implements[someInterface]);

                        if (!interfaceResultTuple.success) {
                            throw new $global.joopl.NotImplementedException({ memberName: interfaceResultTuple.memberName });
                        }
                    }
                }
            }

            return classDef;
        },

        create: function (classDefOrInstance, args) {
            if ($class.isClass(classDefOrInstance)) {
                var instance = TypeUtil.isFunction(classDefOrInstance) ? new classDefOrInstance() : classDefOrInstance;
                instance.$base = TypeUtil.createInstance(instance.$base);

                //TypeUtil.createFields(instance, null);

                if (instance.$base != null && instance.$base != undefined && instance.$base.$base != null && instance.$base.$base != undefined) {
                    instance.$_.$base = instance.$base.$base;
                }

                instance.$_.$derived = instance;
                //TypeUtil.createProperties(instance);

                if (instance.$ctor != null) {
                    instance.$ctor.call(instance, args);
                }

                instance.is = function (clazz) {
                    var allBases = [];
                    var lastBase = this;
                    var isMember = false;

                    if (this instanceof clazz) {
                        isMember = true;
                    } else {
                        while (!isMember && lastBase.$base) {
                            if (!(isMember = lastBase.$base instanceof clazz)) {
                                lastBase = lastBase.$base;
                            }
                        }
                    }

                    return isMember;
                }

                Object.preventExtensions(instance);

                return instance;
            }
            else {
                throw new $global.joopl.NotClassException();
            }
        }
    };

    Object.preventExtensions($class);

    $new = function (classDef, args) {
        throw Error("jOOPL: $new keyboard has been deprecated! In order to instantiate classes, please use the standard JavaScript 'new' operator.");
    };

    Object.preventExtensions($new);

    $def = function (args) {
        return $class.declare(args);
    };

    Object.preventExtensions($def);

    $namespace.register("joopl");

    $global.joopl.ExceptionBase = $def({
        $constructor: function (args) {
            this.$_.message = args.message;
            this.$_.innerException = args.innerException;
        },

        $members:
        {
            get_Message: function () {
                return this.$_.message;
            },

            get_InnerException: function () {
                return this.$_.innerException;
            },

            toString: function () {
                return this.get_Message();
            }
        }
    });

    $global.joopl.NotClassException = $def({
        $constructor: function (args) {
            this.$base.$ctor(
                {
                    Message: "Given reference is not a class definition or an instance of a class",
                    InnerException: null
                }
            );
        },

        $extends: $global.joopl.ExceptionBase
    });

    $global.joopl.NotInterfaceException = $def({
        $constructor: function (args) {
            this.$base.$ctor(
                {
                    message: "This method is not part of interface types"
                }
            );
        },

        $extends: $global.joopl.ExceptionBase
    });

    $global.joopl.ArgumentNullException = $def({
        $constructor: function (args) {
            this.$base.$ctor({ message: "Argument '" + args.ArgName + "' cannot be null" });
            this.$_.argName = args.ArgName;
        },

        $members: {
            get_ArgName: function () {
                return this.$_.argName;
            }
        },

        $extends: $global.joopl.ExceptionBase
    });

    $global.joopl.NotImplementedException = $def({
        $constructor: function (args) {
            this.$base.$ctor(
                {
                    message: !TypeUtil.hasValue(args) || !TypeUtil.hasValue(args.memberName) ?
                                    "A method or property is not implemented"
                                    :
                                    "Method or property '" + args.memberName + "' is not implemented"
                }
            );

            this.$_.memberName = args.memberName;
        },
        $members: {
            get_MemberName: function () {
                return this.$_.memberName;
            }
        },
        $extends: $global.joopl.ExceptionBase
    });
})(undefined);