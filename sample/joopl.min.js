// (c) joopl
// By Matías Fidemraizer (http://www.matiasfidemraizer.com) (http://www.linkedin.com/in/mfidemraizer/en)
// -------------------------------------------------
// http://joopl.codeplex.com
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Keywords
var $namespace = null; // Holds an object to manage namespaces
var $class = null; // Holds an object to manage class declarations and others
var $interface = null; // Holds an object to manage interface declarations and others
var $implements = null; // Holds a function to check if an object implements an interface
var $new = null; // A shortcut to $class.new(...) (OBSOLETE!)
var $def = null; // A shortcut to $class.declare(...)
var $interfacedef = null; // A shortcut to $interface.declare(...)
var $global = {}; // Represents the global scope.

(function (undefined) {
    "use strict";

    var version = "2.2.0";

    // Defines a pseudo-enumeration of type kinds.
    var TypeKinds = {
        Class: "class",
        Interface: "interface"
    };

    // An object containing a set of core features used by jOOPL
    var TypeUtil = {
        // Determines if some identifier is a jOOPL keyword.
        isSystemReservedName: function (name) {
            var reserved = false;

            switch (name) {
                case "$ctor":
                case "$bctor":
                case "$global":
                case "$def":
                case "$interfacedef":
                case "$new":
                case "$namespace":
                case "$extends":
                case "$implements":
                case "$_":
                case "joopl":
                case "typeKind":
                    return true;

                default:
                    return false;
            }
        },

        // It does the core operations to instantiate a class.
        createInstance: function (clazz) {
            var instance = null;

            if (typeof clazz == "function") {
                instance = new clazz();
            }

            return instance;
        },

        isProperty: function (memberName) {
            memberName = memberName.toLowerCase();
            return memberName.indexOf("get_") == 0 || memberName.indexOf("set_") == 0;
        },

        createPropertyFromDescriptor: function (classDef, name, descriptor, context) {
            if (context) {
                if (descriptor.get) {
                    descriptor.get = descriptor.get.bind(context);
                }

                if (descriptor.set) {
                    descriptor.set = descriptor.set.bind(context);
                }
            }

            Object.defineProperty(
                context ? context : classDef.prototype,
                name,
                descriptor
            );
        },

        createProperty: function (classDef, name, getter, setter, inmutable) {
            if (inmutable == undefined) {
                inmutable = false;
            }

            if (!classDef.prototype.hasOwnProperty(name)) {
                if (getter && setter) {

                    Object.defineProperty(
                        classDef.prototype,
                        name, {
                            get: getter,
                            set: setter,
                            configurable: !inmutable,
                            enumerable: true
                        }
                    );
                } else if (getter) {
                    Object.defineProperty(
                        classDef.prototype,
                        name, {
                            get: getter,
                            configurable: !inmutable,
                            enumerable: true
                        }
                    );
                } else if (setter) {
                    Object.defineProperty(
                        classDef.prototype,
                        name, {
                            set: setter,
                            configurable: !inmutable,
                            enumerable: true
                        }
                    );
                }
            }
        },

        // Recursively-creates some class instance fields.
        createFields: function (someInstance, fieldsInstance) {
            someInstance.$_ = fieldsInstance ? fieldsInstance : {};

            if (someInstance.$base) {
                this.createFields(someInstance.$base, someInstance.$_);
            }
        },

        inherits: function (derived, parent) {
            if (parent != null) {
                for (var fieldName in parent.prototype.$_) {
                    if (!derived.prototype.$_[fieldName]) {
                        derived.prototype.$_[fieldName] = parent.prototype.$_[fieldName];
                    }
                }

                var propertyDescriptor = null;

                for (var memberName in parent.prototype) {
                    propertyDescriptor = Object.getOwnPropertyDescriptor(parent.prototype, memberName);

                    if (propertyDescriptor) {
                        if (typeof propertyDescriptor.value == "function") {
                            derived.prototype[memberName] = parent.prototype[memberName];
                        } else {
                            this.createPropertyFromDescriptor(derived, memberName, propertyDescriptor);
                        }
                    } else if (typeof parent.prototype[memberName] == "function") {
                        derived.prototype[memberName] = parent.prototype[memberName];
                    }
                }
            }

            return parent ? parent.prototype : null;
        },

        hasValue: function (someRef) {
            return someRef !== undefined && someRef != null;
        },

        isFunction: function (someRef) {
            return typeof someRef === "function";
        },

        isArray: function (someRef) {
            return typeof someRef === "Array";
        },

        isString: function (someRef) {
            return typeof someRef === "string";
        }
    };

    Object.preventExtensions(TypeUtil);

    $namespace = {
        register: function (path, scopedFunc) {
            var nsIdentifiers = typeof path == "string" ? path.split(".") : null;
            var parentNs = $global;
            var currentNs = null;

            for (var nsIndex = 0; nsIndex < nsIdentifiers.length; nsIndex++) {
                currentNs = nsIdentifiers[nsIndex];

                if (!parentNs[currentNs]) {
                    parentNs[currentNs] = {};

                    Object.defineProperty(
                        parentNs[currentNs], "isNamespace", {
                            get: function () { return true; },
                            configurable: false
                        });
                }

                parentNs = parentNs[currentNs];
            }

            if (scopedFunc) {
                $namespace.using(path, scopedFunc, true);
            }
        },

        alias: function (namespace, alias) {
            $global[alias] = namespace;
        },

        using: function (paths, scopedFunc, scopeIsNs) {
            if (paths === undefined) {
                throw Error("Namespace import failed. No path given!");
            }

            if (typeof paths == "string") {
                paths = [paths];
            }

            var nsIdentifiers = null;
            var parentNs = $global;
            var currentNs = null;
            var isType = false;
            var nsIndex = 0;

            var namespaces = [];

            for (var pathIndex in paths) {
                nsIdentifiers = paths[pathIndex].split(".");

                while (!isType && nsIndex < nsIdentifiers.length) {
                    currentNs = parentNs[nsIdentifiers[nsIndex]];

                    if (currentNs) {
                        if (!TypeUtil.hasValue(currentNs.joopl)) {
                            parentNs = currentNs;
                            nsIndex++;
                        }
                        else {
                            isType = true;
                        }
                    }
                }

                namespaces.push(parentNs);

                parentNs = $global;
                isType = false;
                nsIndex = 0;
            }

            var nsScope = {};
            var nsIndex = 0;
            var tempMember = null;

            for (nsIndex in namespaces) {
                for (var typeName in namespaces[nsIndex]) {
                    if (!nsScope[typeName]) {
                        tempMember = namespaces[nsIndex][typeName];

                        if ((tempMember.prototype !== undefined && !tempMember.prototype.joopl !== undefined) || tempMember.joopl !== undefined) {
                            nsScope[typeName] = tempMember;
                        }
                    }
                    else {
                        throw Error("A type called '" + typeName + "' in current context from another namespace already exists. Create an alias or use a full namespace paths");
                    }
                }
            }

            Object.preventExtensions(nsScope);

            if (scopedFunc !== undefined && typeof scopedFunc == "function") {
                if (scopeIsNs) {
                    scopedFunc.bind(namespaces[nsIndex])();
                } else if (scopedFunc.length == 0) {
                    scopedFunc.bind(nsScope)();
                } else {
                    scopedFunc.bind($global)(nsScope);
                }

                return null;
            } else {
                return nsScope;
            }
        }
    };

    Object.preventExtensions($namespace);

    $interface = {

        isInterface: function (someRef) {
            return TypeUtil.isFunction(someRef)
                                ? someRef.prototype.typeKind : someRef.typeKind;
        },

        declare: function (args) {
            var interfaceDef = function () {
            };

            interfaceDef.prototype.joopl = version;

            Object.defineProperty(interfaceDef.prototype, "typeKind", { value: TypeKinds.Interface, enumerable: true });

            if (typeof args.$extends != "Array") {
                TypeUtil.inherits(interfaceDef, args.$extends);
            }
            else {
                for (var interfaceIndex = 0; interfaceIndex < args.$extends.length; interfaceIndex++) {
                    TypeUtil.inherits(interfaceDef, args.$extends[interfaceIndex]);
                }
            }

            if (args.$members) {
                for (var memberName in args.$members) {
                    interfaceDef.prototype[memberName] = args.$members[memberName];
                }
            }

            return interfaceDef;
        },

        implementz: function (clazz, someInterface) {
            for (var interfaceMember in someInterface.prototype) {
                if (
                        TypeUtil.isFunction(someInterface.prototype[interfaceMember])
                        &&
                        (
                            !TypeUtil.isFunction(clazz.prototype[interfaceMember])
                            || clazz.prototype[interfaceMember] === undefined
                            || clazz.prototype[interfaceMember].length !== someInterface.prototype[interfaceMember].length
                        )
                ) {
                    return { success: false, memberName: interfaceMember };
                }
            }

            return { success: true, memberName: null };
        }
    };

    $implements = $interface.implementz;
    $interfacedef = $interface.declare;

    Object.preventExtensions($interface);
    Object.preventExtensions($interfacedef);
    Object.preventExtensions($implements);

    $class = {
        isClass: function (someRef) {
            return (typeof someRef == "function" ?
                        someRef.prototype.typeKind : someRef.typeKind) == TypeKinds.Class;
        },

        declare: function (args) {
            var classDef = function (args) {
                $class.create(this, args);
            };

            if (args.$extends) {
                TypeUtil.inherits(classDef, args.$extends);
                classDef.prototype.$base = args.$extends;
            } else {
                classDef.prototype = new $global.joopl.Object();
            }

            if (args.$constructor) {
                classDef.prototype.$ctor = args.$constructor;
            } else {
                classDef.prototype.$ctor = function () { };
            }

            if (args.$members) {
                var propertyDescriptor = null;

                for (var memberName in args.$members) {
                    propertyDescriptor = Object.getOwnPropertyDescriptor(args.$members, memberName);

                    if (typeof propertyDescriptor.value == "function") {
                        classDef.prototype[memberName] = args.$members[memberName];
                    } else if (!propertyDescriptor.value) {
                        TypeUtil.createPropertyFromDescriptor(classDef, memberName, propertyDescriptor);
                    }
                }
            }

            if (args.$implements) {
                var interfaceResultTuple = null;

                if (typeof args.$implements != "Array") {
                    interfaceResultTuple = $interface.implementz(classDef, args.$implements);

                    if (!interfaceResultTuple.success) {
                        throw new $global.joopl.NotImplementedException({ memberName: interfaceResultTuple.memberName });
                    }
                }
                else {
                    for (var someInterface in args.$implements) {
                        interfaceResultTuple = $interface.implementz(classDef, args.$implements[someInterface]);

                        if (!interfaceResultTuple.success) {
                            throw new $global.joopl.NotImplementedException({ memberName: interfaceResultTuple.memberName });
                        }
                    }
                }
            }

            return classDef;
        },

        create: function (instance, args) {
            if (typeof instance.$base == "function") {
                instance.$base = new instance.$base(args);
            }

            //TypeUtil.createFields(instance, null);

            if (instance.$base != null && instance.$base != undefined && instance.$base.$base != null && instance.$base.$base != undefined) {
                instance.$_.$base = instance.$base.$base;
            }

            instance.$_.$derived = instance;

            if (instance.$ctor != null) {
                instance.$ctor.call(instance, args);
            }

            //Object.preventExtensions(instance);

            return instance;
        }
    };

    Object.preventExtensions($class);

    $new = function (classDef, args) {
        throw Error("jOOPL: $new keyboard has been deprecated! In order to instantiate classes, please use the standard JavaScript 'new' operator.");
    };

    Object.preventExtensions($new);

    $def = function (args) {
        return $class.declare(args);
    };

    Object.preventExtensions($def);

    $namespace.register("joopl");

    $global.joopl.Object = function () {
        this.$_ = {};
    };

    $global.joopl.Object.prototype = {
        get joopl() { return version; },
        get typeKind() { return "class"; },

        isTypeOf: function (type) {
            var allBases = [];
            var lastBase = this;
            var isMember = false;

            if (this instanceof type) {
                isMember = true;
            } else {
                while (!isMember && lastBase.$base) {
                    if (!(isMember = lastBase.$base instanceof type)) {
                        lastBase = lastBase.$base;
                    }
                }
            }

            return isMember;
        }
    };

    $global.joopl.ExceptionBase = $def({
        $constructor: function (args) {
            this.$_.message = args.message;
            this.$_.innerException = args.innerException;
        },

        $members:
        {
            get_Message: function () {
                return this.$_.message;
            },

            get_InnerException: function () {
                return this.$_.innerException;
            },

            toString: function () {
                return this.get_Message();
            }
        }
    });

    $global.joopl.NotClassException = $def({
        $constructor: function (args) {
            this.$base.$ctor(
                {
                    Message: "Given reference is not a class definition or an instance of a class",
                    InnerException: null
                }
            );
        },

        $extends: $global.joopl.ExceptionBase
    });

    $global.joopl.NotInterfaceException = $def({
        $constructor: function (args) {
            this.$base.$ctor(
                {
                    message: "This method is not part of interface types"
                }
            );
        },

        $extends: $global.joopl.ExceptionBase
    });

    $global.joopl.ArgumentNullException = $def({
        $constructor: function (args) {
            this.$base.$ctor({ message: "Argument '" + args.ArgName + "' cannot be null" });
            this.$_.argName = args.ArgName;
        },

        $members: {
            get_ArgName: function () {
                return this.$_.argName;
            }
        },

        $extends: $global.joopl.ExceptionBase
    });

    $global.joopl.NotImplementedException = $def({
        $constructor: function (args) {
            this.$base.$ctor(
                {
                    message: !TypeUtil.hasValue(args) || !TypeUtil.hasValue(args.memberName) ?
                                    "A method or property is not implemented"
                                    :
                                    "Method or property '" + args.memberName + "' is not implemented"
                }
            );

            this.$_.memberName = args.memberName;
        },
        $members: {
            get_MemberName: function () {
                return this.$_.memberName;
            }
        },
        $extends: $global.joopl.ExceptionBase
    });
})(undefined);